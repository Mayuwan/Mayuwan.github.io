---
layout: post
title:  "JDK8中的Hashmap为什么树化"
date:   2018-12-09 22:14:54
categories: JDK
tags: JDK源码
---

* content
{:toc}

## 前言

众所周知，HashMap的源码在JDK8时有很大的改动，我将会对这些改动进行说明，并说明为什么要进行红黑树化的改进。


### JDK8中HashMap的改变

1.JDK7中，发生哈希碰撞时，将键值对添加到链表头部，JDK8是将键值对添加到链表尾部。

2.JDK8中，如果链表的长度超过8，将会将链表转化为红黑树。

3.容量的初始化：JDK7的HashMap在构造时会对容量进行初始化，而JDK8是在首次向HashMap总中执行put操作时，对容量进行初始化，也就是说，JDK8的HashMap使用了懒汉模式（在使用时才初始化），避免了初始化后却不用的资源浪费。

4.容量的大小：JDK8的容量大小必须为2的指数，即2，4，8，16，32，64... 这与hashmap的get操作有关。

### 为什么要进行树化的改造呢?

主要是为了避免哈希碰撞拒绝服务攻击。

从性能角度来看：解决哈希冲突时使用链表，插入和删除的效率很高，只需O(1)的时间复杂度，但对于查询而言，则需要O(n)的时间负责度。但红黑树的插入，删除，查询的最差时间复杂度为O(logn)。恶意代码可以利用大量数据与服务器交互，比如String的hashcode函数的强度很弱，有人可以很容易的构造出大量hashcode相同的String对象。如果向服务器一次提交数万个hashcode相同的字符串，服务器的查询时间过长，让服务器的CPU被大量占用，当有其他更多的请求时服务器会拒绝服务。而使用红黑树可以将查询时间降低到一定的数量级，可以有效避免哈希碰撞拒绝服务攻击。